const { Op } = require('sequelize');
const models = require('../models');

/**
 * Calculates the revenue generated by all contracts during a period of an investment
 * @param {object} contracts - Contracts signed by the client
 * @param {object} investment - the investment made by investors
 * @returns {number}
 */
const calculateContractRevenue = (contracts, investment) => {
  let totalContractRevenue = 0;

  for (const contract of contracts) {
    const { start_date, end_date, monthly_rate } = contract;
    const investmentStart = new Date(investment.starting_date);
    const investmentEnd = new Date(investment.ending_date);
    const contractStart = new Date(start_date);

    // If the contract started before the investment, it should not be included.
    if (contractStart < investmentStart) {
      continue;
    }

    let current = new Date(start_date);
    while (current < new Date(end_date)) {
      const monthStart = new Date(current.getFullYear(), current.getMonth(), 1);
      const monthEnd = new Date(current.getFullYear(), current.getMonth() + 1, 0);

      if (monthStart <= investmentEnd && monthEnd >= investmentStart) {
        totalContractRevenue += parseFloat(monthly_rate);
      }

      current.setMonth(current.getMonth() + 1);
    }
  }

  return totalContractRevenue;
};


/**
 * Calculates the total revenue from client services based on specified criteria.
 *
 * @param {object} clientServices - The ClientServices object model
 * @param {boolean} [options.withTaxes=false] - Whether to include company-borne taxes in the revenue.
 * @returns {number} The calculated total services revenue.
 */
async function calculateServiceRevenue({ clientServices, withTaxes = false }) {
    let totalRevenue = 0;
    clientServices.forEach(service => {
        let serviceRevenue = parseFloat(service.price) || 0;
        if (withTaxes && service.Tax && service.Tax.bearer === 'Company') {
            const taxAmount = serviceRevenue * (parseFloat(service.Tax.rate) / 100);
            serviceRevenue -= taxAmount; // Subtracting company-borne tax from price
        }
        totalRevenue += serviceRevenue;
    });

    return totalRevenue;
}

/**
 * Calculates the total revenue from client services based on specified criteria.
 *
 * @param {object} options - The options for calculation.
 * @param {Date} [options.startDate] - The start date of the period.
 * @param {Date} [options.endDate] - The end date of the period.
 * @param {number} [options.profile_id] - The ID of the profile to filter by.
 * @param {boolean} [options.withTaxes=false] - Whether to include company-borne taxes in the revenue.
 * @returns {Promise<number>} The calculated total services revenue.
 */
async function calculateServiceRevenueExlcTax({ startDate, endDate, profile_id, withTaxes = false }) {
    const where = {};
    if (startDate && endDate) {
        where.transaction_date = { [Op.between]: [startDate, endDate] };
    }
    if (profile_id) {
        where.profile_id = profile_id;
    }

    const clientServices = await models.ClientService.findAll({
        where,
        include: [{ model: models.Tax, attributes: ['rate', 'bearer'] }]
    });

    const totalRevenue = calculateServiceRevenue({ clientServices, withTaxes });
    return totalRevenue;
}

async function calculateMonthlyReportMetrics(filters) {
  const { year, month, clientId, branchId, profile_id } = filters;
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0, 23, 59, 59, 999);

  const where = {
    profile_id,
    transaction_date: {
      [Op.between]: [startDate, endDate],
    },
  };

  const creationWhere = {
    profile_id,
    created_at: {
      [Op.between]: [startDate, endDate],
    },
  }

  if (branchId) {
    where.branch_id = branchId;
  }
  
  if (clientId) {
    where.client_id = clientId;
    creationWhere.id = clientId;
  }

  // Revenue Calculation
  const incomeWhere = { ...where };
  delete incomeWhere.client_id;
  const incomeRevenue = await models.Income.sum('amount', { where: incomeWhere });

  const serviceRevenue = await calculateServiceRevenueExlcTax({
    startDate,
    endDate,
    profile_id,
  });

  const contractWhere = {
    profile_id,
    [Op.and]: [
      { start_date: { [Op.lte]: endDate } },
      { end_date: { [Op.gte]: startDate } }
    ]
  };
  if (clientId) contractWhere.client_id = clientId;

  const includeOptions = [];
  if (branchId) {
    includeOptions.push({
      model: models.Office,
      where: { branch_id: branchId },
      required: true,
    });
  }
  
  const contracts = await models.Contract.findAll({
    where: contractWhere,
    include: includeOptions,
  });
  let contractsRevenue = 0;
  contracts.forEach(contract => {
    contractsRevenue += parseFloat(contract.monthly_rate);
  });

  const totalRevenue = (incomeRevenue || 0) + (serviceRevenue || 0) + (contractsRevenue || 0);

  // New Clients
  const newClientsWhere = {
    created_at: {
      [Op.between]: [startDate, endDate],
    },
  };
  if (clientId) newClientsWhere.id = clientId;
  const newClients = await models.Client.count({ where: newClientsWhere });

  // Contracts Signed
  const contractsSignedWhere = { ...creationWhere };
  let contractsSigned;
  if (branchId) {
    contractsSigned = await models.Contract.count({
      where: contractsSignedWhere,
      include: [{
        model: models.Office,
        where: { branch_id: branchId },
        required: true
      }]
    });
  } else {
    contractsSigned = await models.Contract.count({ where: contractsSignedWhere });
  }

  // Occupancy Rate
  const occupiedOfficesWhere = {
    profile_id,
    [Op.and]: [
      { start_date: { [Op.lte]: endDate } },
      { end_date: { [Op.gte]: startDate } }
    ]
  };
  const occupiedOfficesInclude = [];
  if (branchId) {
    occupiedOfficesInclude.push({
      model: models.Office,
      where: { branch_id: branchId },
      required: true,
    });
  }

  const occupiedOffices = await models.Contract.count({
    where: occupiedOfficesWhere,
    include: occupiedOfficesInclude,
    distinct: true,
    col: 'office_id'
  });

  const totalOfficesWhere = {};
  if (branchId) totalOfficesWhere.branch_id = branchId;
  const totalOffices = await models.Office.count({ where: totalOfficesWhere });
  const occupancyRate = totalOffices > 0 ? (occupiedOffices / totalOffices) * 100 : 0;

  return {
    revenue: totalRevenue,
    newClients,
    contractsSigned,
    occupancyRate,
  };
}

module.exports = {
  calculateContractRevenue,
  calculateServiceRevenue,
  calculateMonthlyReportMetrics,
  calculateServiceRevenueExlcTax,
};
